Outline
=======

- Introduction
  - We're writing too much code
  - Simple
      - Functions - Abstraction in the small
      - Objects and traits - Abstraction in the large
  - Scalable
    - Can be molded by adding libraries
    - Can be used from tiny to large systems.
    - Flexible syntax - can be used to make internal DSLs
    - Combination of OO and functional
  - Who uses it
    - Twitter
    - Foursquare
    - LinkedIn
  - Where it can be run
    - Scripting language
    - Compiled to JAR
    - Web apps
    - [Android](https://github.com/pocorall/scaloid)
    - [Javascript](http://www.scala-js.org/)
        - example  scala-js-example-app/index-fastopt.html
  - Build Tools
    - Maven
    - Gradle
    - SBT
- Intro
  - Hello world is very simple
  - Variable declaration starts with val/var.
  - Optionally include variable type
  - Function declaration using def adds to enclosing scope
  - Functions can be assigned to variables.
  - Takeaway: anything can be declared anywhere. Functions in classes, classes in functions, functions in functions, classes in classes.
  - Java interop very straightforward
    - No special consideration for checked exceptions
- Basic OO
  - OO at very core
    - AnyVal and AnyRef
  - Classes
    - Can write classes in Java style with fields/methods
    - Fields can be introduced automatically with primary constructor
    - Can use BeanProperty to generate JavaBean style getters/setters
    - Case classes
        - Immutable by default
        - Autogenerated toString/equality/unapply
  - Companion objects
    - Replacement for static fields/methods
    - Cannot be mixed during declaration with regular objects
  - Traits
    - interfaces/mix-ins rolled into one
    - Cannot have parameters
    - Similar to Java 8 interface default methods
    - Stacking/ordering traits
    - Pretends to be multiple inheritence
        - Hierarchy linearlized
  - Implicit Conversions
      - .NET Implicit conversions ++
      - Allow a huge spectrum of expressiveness
        - Extension methods/monkeypatching
        - Can implement typeclasses
  - BeanProperties/BeanInfo
  - Type specialization
    - Java does type erasure on generics
    - Erasure results in inefficient code for primitive types
    - Can use specialization strategically to get efficiency
- Functional
  - Lambda expressions are closures (unlike Java 8)
  - No special consideration for SAMs
  - Higher order functions
  - Tuples
    - Object with multiple related values
    - Useful for non-public code
  - Currying
    - Decompose n-arity function into unary functions
    - Helper function available to curry n-arity functions
    - Can partially apply function n number of times to get result
    - Useful for algorithms where partial application is useful
    - Curried function execution syntax a bit cumbersome (unlike e.g. F#, Haskell)
  - Recursion
    - Works well for a large number of algorithms
    - Great match for implementing algorithms statelessly
    - Support for verified self-tailcalls
    - Trampolines for mutual recursion etc.
    - Requires return type specified for recursive functions
  - Case classes
    - Described in OO section
    - Unapplication implemented automatically
    - Great for data modelling
  - Pattern matching
    - Need extractor (unapply)
    - Functional alternative to polymorphism
        - [Independently Extensible Solutions to the Expression Problem](http://zenger.org/papers/fool05.pdf)
    - Huge number of Scala types can be pattern matched
    - Can make for a useful tool for a lot of algorithms
        - See also: Parser combinators, Untyped actors
  - For comprehension
    - Equivalent to
        - LINQ syntax in Java
        - List comprehensions in Python/Erlang
        - Haskell's do notation
    - Monadic comprehension
    - Syntactic sugar over
        - map
        - flatMap
        - withFilter
        - forEach
    - Expression like everything else in Scala
    - Replaces for, foreach from Java as well
    - Unification: Functions are objects. Objects can be treated as functions
- Collections
  - [Collections Performance Characteristics](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html)
  - Scala has immmutable/mutable collections. Prefers immutable
  - Immutable collections made practical with strategic structural sharing
  - Standard operations
    - Head  - car
    - Tail  - cdr
    - Reverse
    - Fold
    - Map
    - Filter
    - Partition
  - Convenient factory methods on all levels of collection hierarchy
    - That + immutability allows selection of optimal type without hassle
  - Operator with : on right reverse associativity. :: is cons operator
  - Pattern matching allows algorithmic processing of collections
  - Collections can be lifted to parallel collections
  - Can be operated upon with for comprehension and generate same type of collection
  - Can be converted back and forth to Java collections using implicit conversions
- Demos
  - Hello world using scala script
  - Hello world with scalajs
  - Scala app with gradle
- Conclusion
  - More stuff
    - Typeclasses
    - Higher kinded types
        - Allow more than one level of type variables
        - For instance Container as a kind for types like List[T], Vector[T] on which operations can be defined
            without defining the actual type it's polymorphic on
    - Macros
  - Learning Resources
    - [ScalaDoc](http://docs.scala-lang.org/index.html)
    - [Scala for the impatient](http://www.horstmann.com/scala/index.html)
    - [Programming In Scala](http://www.artima.com/shop/programming_in_scala_2ed)
    - [Twitter Scala School](https://twitter.github.io/scala_school/)
    - [Functional Programming In Scala](http://www.manning.com/bjarnason/)
  - Examples of DSLs
    - [Scalding](https://github.com/twitter/scalding)
    - [Akka](http://akka.io/)
    - [SBT](http://www.scala-sbt.org/)
  - Downsides
    - Slow?
    - Code can be as hard to comprehend as needed
    - DSLs reflect on the base language
    - ABI
    - [Ask Paul Philips](https://www.youtube.com/watch?v=uiJycy6dFSQ)